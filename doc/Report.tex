\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{enumitem}

\begin{document}

\title{ARM Final Report}
\author{
  Abhinav Mishra,
  Arthur-Mihai Niculae,
  Szilveszter Szekely,
  Tom Bellingham
}

\maketitle

\section{Introduction}

\section{Assembler}

\subsection{Design}

The assembler has been implemented according to the two pass design provided in
the specification file. However we read the input file only once and iterate
over the stored instructions twice.

The assembler has four major components:
\begin{itemize}[noitemsep,topsep=0pt]
  \item \textbf{Tokenizer}:
    to tokenize the instruction.
  \item \textbf{Parser}:
    to parse the tokenized instruction.
  \item \textbf{Dictionary}:
    to look for the mnemonics and their respective values.
  \item \textbf{Instruction Generator}:
    to generate the final binary encoding.
\end{itemize}

\subsection{Implementation}

Every line in the instruction is fed into the tokenizer which returns a list
of tokens. These tokens are then passed to the parser which recognizes the
mnemonic and parses the whole instruction into a usable format. While the
instruction is being parsed the dictionary is used extensively to classify the
tokens. Once the instruction has been parsed, it is passed to the instruction
generator which connects all the components of the parsed tokens and generates
a final binary encoding of the instruction.

In this implementation of the assembler, majority of the data structures are
being reused from the emulator.

\subsection{Extensions}

The assembler has been extended to implement some more instructions comments.
All the instructions are now of the type:
\textbf{opcode\{cond\} \{operands\}}
\begin{itemize}[noitemsep,topsep=0pt]
  \item \textbf{opcode}: Basic Instruction
  \item \textbf{cond}: Ex: eq, hi, al, cc, etc.
  \item \textbf{operands}: Ex: registers, immediate values.
\end{itemize}
Example: andeq r0, r0, r0, mulhi r1, r2, r3.

It also supports comments along with the instructions which can be used to
explain the code.

\section{Extension}

\subsection{Acknowledgement}

The group takes this opportunity to gratefully acknowledge the people whose
libraries and tutorials have been used to help make this extension.

\begin{itemize}[noitemsep,topsep=0pt]
  \item \textbf{Cambridge University Tutorials} for Baking Pi â€“
    Operating Systems Development.
  \item \textbf{Valvers.com} for Bare Metal Programming in C.
  \item \textbf{Brian Sidebotham} for Raspberry Pi Baremetal Libraries.
  \item \textbf{PiFox Team} for imager.py utility
  \item \textbf{D. Richard Hipp} for makeheaders utilility
\end{itemize}

\subsection{Idea}

\subsection{Implementation}

\subsection{Result}

\section{Group Reflection}

\section{Personal Reflection}

\subsection{Abhinav Mishra}

\subsection{Arthur-Mihai Niculae}

\subsection{Szilveszter Szekely}

I was one of the most experienced members of the group, but this also became
a disadvantage in the beginning. As I rushed ahead with the implementation of
the tasks I did not communicate enough with my teammates which created friction
in our group. This has been reflected in my WebPA feedback. After we discussed
this issue I tried taking an approach that more heavily relies on group work
rather than me doing things on my own. By the time this report is written
I believe I have gotten to a point where I can more fluidly work with my
teammates.

My experience also yielded, in my opinion, significant benefits. I argued
strongly for some design decisions that were initially inconvenient, but had
long term positive consequences. For example, arguing for using checkpatch from
Linux generated lots of style errors that had to be fixed in the beginning, but
our codebase now has a consistent style.

\subsection{Tom Bellingham}

\end{document}

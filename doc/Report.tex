\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{enumitem}

\begin{document}

\title{ARM Final Report}
\author{
  Abhinav Mishra,
  Arthur-Mihai Niculae,
  Szilveszter Szekely,
  Tom Bellingham
}

\maketitle

\section{Introduction}

\section{Assembler}

\subsection{Design}

The assembler has been implemented according to the two pass design provided in
the specification file. However we read the input file only once and iterate
over the stored instructions twice.

The assembler has four major components:
\begin{itemize}[noitemsep,topsep=0pt]
  \item \textbf{Tokenizer}:
    to tokenize the instruction.
  \item \textbf{Parser}:
    to parse the tokenized instruction.
  \item \textbf{Dictionary}:
    to look for the mnemonics and their respective values.
  \item \textbf{Instruction Generator}:
    to generate the final binary encoding.
\end{itemize}

\subsection{Implementation}

Every line in the instruction is fed into the tokenizer which returns a list
of tokens. These tokens are then passed to the parser which recognizes the
mnemonic and parses the whole instruction into a usable format. While the
instruction is being parsed the dictionary is used extensively to classify the
tokens. Once the instruction has been parsed, it is passed to the instruction
generator which connects all the components of the parsed tokens and generates
a final binary encoding of the instruction.

In this implementation of the assembler, majority of the data structures are
being reused from the emulator.

\subsection{Extensions}

The assembler has been extended to implement some more instructions comments.
All the instructions are now of the type:
\textbf{opcode\{cond\} \{operands\}}
\begin{itemize}[noitemsep,topsep=0pt]
  \item \textbf{opcode}: Basic Instruction
  \item \textbf{cond}: Ex: eq, hi, al, cc, etc.
  \item \textbf{operands}: Ex: registers, immediate values.
\end{itemize}
Example: andeq r0, r0, r0, mulhi r1, r2, r3.

It also supports comments along with the instructions which can be used to
explain the code.

\section{Extension}

\subsection{Acknowledgement}

We gratefully acknowledge those  whose libraries and tutorials have been used 
to help make this extension.

\begin{itemize}[noitemsep,topsep=0pt]
  \item \textbf{Cambridge University Tutorials} for Baking Pi â€“
    Operating Systems Development.
  \item \textbf{Valvers.com} for Bare Metal Programming in C.
  \item \textbf{Brian Sidebotham} for Raspberry Pi Baremetal Libraries.
  \item \textbf{PiFox Team} for imager.py utility
  \item \textbf{D. Richard Hipp} for makeheaders utilility
\end{itemize}

\subsection{Description}
Our extension features graphical output driven by our own software renderer, 
in combination with controller input, to provide a competitive multiplayer 
bare metal mini-game experience.
\subsection{Design Decisions}
Our objective has been to learn about and exploit as many facets of the 
raspberry pi's functionality as possible; pursuing an interactive experience 
enabled us to do this effectively by compartmentalising research and 
implementation tasks between group members. We initially hoped to make use 
of graphics, sound, and controller input.

Due to time constraints and implementation challenges, we continually altered 
and evolved our ideas to accommodate a range of pi functionality whilst still 
building an interactive experience.
\subsection{Implementation Challenges}
Initially we had hoped to use joysticks for input, which were replaced with 
1-bit buttons, and we had hoped to render many fast moving objects, which were 
substituted with fewer, slower objects.

lack of documentation (graphics, i/o components)
graphics, io, dma, software rendering... 
\section{Group Reflection}

\section{Personal Reflection}

\subsection{Abhinav Mishra}

\subsection{Arthur-Mihai Niculae}

\subsection{Szilveszter Szekely}

I was one of the most experienced members of the group, but this also became
a disadvantage in the beginning. As I rushed ahead with the implementation of
the tasks I did not communicate enough with my teammates which created friction
in our group. This has been reflected in my WebPA feedback. After we discussed
this issue I tried taking an approach that more heavily relies on group work
rather than me doing things on my own. By the time this report is written
I believe I have gotten to a point where I can more fluidly work with my
teammates.

My experience also yielded, in my opinion, significant benefits. I argued
strongly for some design decisions that were initially inconvenient, but had
long term positive consequences. For example, arguing for using checkpatch from
Linux generated lots of style errors that had to be fixed in the beginning, but
our codebase now has a consistent style.

\subsection{Tom Bellingham}

\end{document}
